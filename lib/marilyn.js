(function() {

	// _socketConnection should be shared between all the models
	// it's a single connection to the server
	var _socketConnection;

	// the is where all the models will be stored so getters can be used to retrieve them
	var _models = {};

	// the socket.io on function isn't avalible until Marilyn gets the socketConnection
	// after it gets this connection all the on events need to get attached to socket.io
	var _eventBuffer = {};

	// get a model from the global Marilyn object
	function _modelGet(modelName) {
		return _models[modelName];
	}

	// create a model and assign it to the global Marilyn object
	function _modelSet(modelName, init) {

		// this model object will be what contains all the CRUD functions
		// it is an object so we can use the 'new' keyword to create one
		var model = _models[modelName] = function(object) {
			object = object || {};
			object.save = _resultSave;
			return object;
		};

		model.name = modelName;

		// setup the private variables of the model
		// collection will store all the data in the model
		model._collection = [];
		model._id = 0;

		model._befores = {};
		model._afters = {};

		model._receivers = {};

		// this is a variable that will be overrided each time scope needs to be retained
		model._retainScope = function() {
		};

		// private functions
		model._nextId = function() {
			model._id++;
			return model._id;
		};

		// this is for saving changes to the result generated by read and readOne
		function _resultSave(callback) {

			// "this" is the result or a new object being created
			var _this = this || {};

			// the save can save a new or existing object using the create or update methods
			// this should trigger the correct befores and afters
			// it should always trigger all the before saves and after saves regardless of it being a create or update

			// check if there are any befores assigned to the save
			if (model._befores.hasOwnProperty('save')) {
				model._retainScope = model._befores['save'];
				model._retainScope(_this, function() {
					runCRUD(_this);
				});
			} else {
				runCRUD(_this);
			}

			// run the correct CRUD method
			function runCRUD(object) {

				// CREATE
				// this object is being newly created
				if (!object.hasOwnProperty('__id')) {

					// check if there are any befores assigned to the create
					if (model._befores.hasOwnProperty('create')) {
						model._retainScope = model._befores['create'];
						model._retainScope(object, function() {
							runCreateComplete(object);
						});
					} else {
						runCreateComplete(object);
					}

				}

				// UPDATE
				// check if the object has come from a read and needs to be updated
				else {

					// check if there are any befores assigned to the update
					if (model._befores.hasOwnProperty('update')) {
						model._retainScope = model._befores['update'];
						model._retainScope({
							'__id' : object.__id
						}, object, function() {
							runUpdateComplete(object);
						});
					} else {
						runUpdateComplete(object);
					}

				}

			}

			function runCreateComplete(object) {

				model.createSilent(object, function(err, result) {

					// check if there are any afters assigned to the create
					if (model._afters.hasOwnProperty('create')) {
						model._retainScope = model._afters['create'];
						model._retainScope(object, function() {
							runSaves(err, result);
						});
					} else {
						runSaves(err, result);
					}

				});

			}

			function runUpdateComplete(object) {

				model.updateSilent({
					'__id' : object.__id
				}, object, function(err, results) {

					var result = results[0];

					// check if there are any afters assigned to the update
					if (model._afters.hasOwnProperty('update')) {
						model._retainScope = model._afters['update'];
						model._retainScope(result, function() {
							runSaves(err, result);
						});
					} else {
						runSaves(err, result);
					}

				});

			}

			function runSaves(err, result) {

				// check if there are any afters assigned to the save
				if (model._afters.hasOwnProperty('save')) {
					model._retainScope = model._afters['save'];
					model._retainScope(result, function() {
						runCallback(err, result);
					});
				} else {
					runCallback(err, result);
				}

			}

			function runCallback(err, result) {

				model.inform('save', result);

				// callback if from the parent function
				if (callback) {
					model._retainScope = callback;
					model._retainScope(err, result);
				}

			}

		}

		// Socket.IO events

		model.on = function(eventType, callback) {

			// if the socketConnection is not setup the ons need to get buffered and applied later
			if (!_socketConnection) {

				// set the model name property if not already set
				if (!_eventBuffer.hasOwnProperty(model.name)) {
					_eventBuffer[model.name] = {};
				}

				// set the callback into the onBuffer onject
				_eventBuffer[model.name][eventType] = callback;

			} else {

				_socketConnection.on(eventType, function(data) {
					model._retainScope = callback;
					model._retainScope(data);
				});

			}

		};

		model.emit = function(eventType, data) {

			if (_socketConnection) {
				_socketConnection.emit(eventType, data);
			}

		};

		// internal events

		model.before = function(eventType, callback) {
			model._befores[eventType] = callback;
		};

		model.beforeRemove = function(eventType) {
			model._befores[eventType] = function() {
			};
		};

		model.after = function(eventType, callback) {
			model._afters[eventType] = callback;
		};

		model.afterRemove = function(eventType) {
			model._afters[eventType] = function() {
			};
		};

		model.inform = function(eventType, data) {
			if (model._receivers[eventType]) {
				model._retainScope = model._receivers[eventType];
				model._retainScope(data);
			}
		};

		model.receive = function(eventType, callback) {
			model._receivers[eventType] = callback;
		};

		model.receiveRemove = function(eventType) {

			if (_.isEmpty(eventType)) {
				model._receivers = {};
			} else {
				model._receivers[eventType] = function() {
				};
			}

		};

		// query methods

		model.collection = function(collection) {

			// check if the collection is an array
			if (!_.isArray(collection)) {
				// TODO throw error
				return;
			}

			for (var i = 0, j = collection.length; i < j; i++) {
				collection[i].__id = model._nextId();
			}

			model._collection = collection;

		};

		model.create = function(element, callback) {

			// check if there are any befores assigned to the create
			if (model._befores.hasOwnProperty('create')) {
				model._retainScope = model._befores['create'];
				model._retainScope(element, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

			function runComplete() {

				model.createSilent(element, function(err, result) {

					// check if there are any afters assigned to the create
					if (model._afters.hasOwnProperty('create')) {
						model._retainScope = model._afters['create'];
						model._retainScope(element, function() {
							runCallback(err, result);
						});
					} else {
						runCallback(err, result);
					}

				});

			}

			function runCallback(err, result) {

				model.inform('create', result);

				// callback if from the parent function
				if (callback) {
					model._retainScope = callback;
					model._retainScope(err, result);
				}

			}

		};

		model.createSilent = function(element, callback) {

			var err = null;

			// set the internal id using the model's next id
			element.__id = model._nextId();

			model._collection.push(element);

			if (callback) {
				model._retainScope = callback;
				model._retainScope(err, element);
			}

		};

		model.read = function(query, callback) {

			// check if there are any befores assigned to the read
			if (model._befores.hasOwnProperty('read')) {
				model._retainScope = model._befores['read'];
				model._retainScope(query, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

			function runComplete() {

				model.readSilent(query, function(err, results) {

					// check if there are any afters assigned to the read
					if (model._afters.hasOwnProperty('read')) {
						model._retainScope = model._afters['read'];
						model._retainScope(results, function() {
							runCallback(err, results);
						});
					} else {
						runCallback(err, results);
					}

				});

			}

			function runCallback(err, results) {

				model.inform('read', results);

				// callback if from the parent function
				if (callback) {
					model._retainScope = callback;
					model._retainScope(err, results);
				}

			}

		};

		model.readSilent = function(query, callback) {

			var err = null;

			var readAll = false;

			// if no query was passed
			if ( typeof query === 'function') {
				callback = query;
				readAll = true;
			}

			// or if the query object was empty
			else if (_.isEmpty(query)) {
				readAll = true;
			}

			var results = [];

			if (readAll) {
				results = model._collection;
			} else {
				results = _.where(model._collection, query);
			}

			// check if results were found
			if (results.length == 0) {
				err = 'item not found';
			}

			// add the save callback to the results
			_.each(results, function(element) {
				element.save = _resultSave;
			});

			if (callback) {
				model._retainScope = callback;
				model._retainScope(err, results);
			}

		};

		model.readOne = function(query, callback) {

			// check if there are any befores assigned to the readOne
			if (model._befores.hasOwnProperty('readOne')) {
				model._retainScope = model._befores['readOne'];
				model._retainScope(query, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

			function runComplete() {

				model.readOneSilent(query, function(err, result) {

					// check if there are any afters assigned to the readOne
					if (model._afters.hasOwnProperty('readOne')) {
						model._retainScope = model._afters['readOne'];
						model._retainScope(result, function() {
							runCallback(err, result);
						});
					} else {
						runCallback(err, result);
					}

				});

			}

			function runCallback(err, result) {

				model.inform('readOne', result);

				// callback if from the parent function
				if (callback) {
					model._retainScope = callback;
					model._retainScope(err, result);
				}

			}

		};

		model.readOneSilent = function(query, callback) {

			var err = null;

			var results = _.where(model._collection, query);

			var result = null;

			if (results[0]) {
				result = results[0];
				result.save = _resultSave;
			} else {
				err = 'item not found';
			}

			if (callback) {
				model._retainScope = callback;
				model._retainScope(err, result);
			}

		};

		model.update = function(query, changes, callback) {

			// check if there are any befores assigned to the update
			if (model._befores.hasOwnProperty('update')) {
				model._retainScope = model._befores['update'];
				model._retainScope(query, changes, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

			function runComplete() {

				model.updateSilent(query, changes, function(err, results) {

					// check if there are any afters assigned to the update
					if (model._afters.hasOwnProperty('update')) {
						model._retainScope = model._afters['update'];
						model._retainScope(results, function() {
							runCallback(err, results);
						});
					} else {
						runCallback(err, results);
					}

				});

			}

			function runCallback(err, results) {

				model.inform('update', results);

				// callback if from the parent function
				if (callback) {
					model._retainScope = callback;
					model._retainScope(err, results);
				}

			}

		};

		model.updateSilent = function(query, changes, callback) {

			var err = null;

			var results = _.where(model._collection, query);

			if (results.length > 0) {

				_.each(results, function(element) {

					_.each(changes, function(value, key) {
						element[key] = value;
					});

				});

			} else {
				err = 'item not found';
			}

			if (callback) {
				model._retainScope = callback;
				model._retainScope(err, results);
			}

		};

		model.del = model['delete'] = function(query, callback) {

			// check if there are any befores assigned to the delete
			if (model._befores.hasOwnProperty('delete')) {
				model._retainScope = model._befores['delete'];
				model._retainScope(query, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

			function runComplete() {

				model.deleteSilent(query, function(err, results) {

					// check if there are any afters assigned to the delete
					if (model._afters.hasOwnProperty('delete')) {
						model._retainScope = model._afters['delete'];
						model._retainScope(results, function() {
							runCallback(err, results);
						});
					} else {
						runCallback(err, results);
					}

				});

			}

			function runCallback(err, results) {

				model.inform('delete', results);

				// callback if from the parent function
				if (callback) {
					model._retainScope = callback;
					model._retainScope(err, results);
				}

			}

		};

		model.delSilent = model.deleteSilent = function(query, callback) {

			var err = null;

			var results = _.where(model._collection, query);

			if (results.length > 0) {

				_.each(results, function(element) {

					var index = _.indexOf(model._collection, element);
					model._collection.splice(index, 1);

				});

			} else {
				err = 'item not found';
			}

			if (callback) {
				model._retainScope = callback;
				model._retainScope(err, results);
			}

		};

		// run the callback init function if it was passed
		if (init) {

			// make "this" work inside of the callback
			model.init = init;
			model.init();

			// delete the init function as it should only run once
			delete model.init;

		}

		return model;

	}

	// create the Marilyn object
	var Marilyn = {};

	Marilyn.VERSION = '0.9.0';

	Marilyn.config = function(socketConnection) {

		_socketConnection = socketConnection;

		// setup the ons
		for (var model in _eventBuffer) {

			for (var eventType in _eventBuffer[model]) {

				// this has to be a self executing function to retain scope through dependency injection
				(function(model, eventType, callback) {

					_socketConnection.on(eventType, function(data) {
						model._retainScope = callback;
						model._retainScope(data);
					});

				})(_models[model], eventType, _eventBuffer[model][eventType]);

			}

		}

		// _eventBuffer = {};

	};

	Marilyn.model = function(modelName, init) {
		if (_models[modelName]) {
			return _modelGet(modelName);
		} else {
			return _modelSet(modelName, init);
		}
	};

	Marilyn.modelRemove = function(modelName) {
		_models[modelName] = null;
	};

	Marilyn.receiveRemove = function(modelName) {
		for (var model in _models) {
			_models[model].receiveRemove();
		}
	};

	window.Marilyn = Marilyn;

})();
