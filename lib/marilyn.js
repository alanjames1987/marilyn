(function(factory) {

	// define marilyn using AMD
	if (typeof define === 'function' && define.amd) {
		define(['underscore'], factory);
	}

	// define marilyn by adding it to the window object
	else {
		window.Marilyn = window.marilyn = factory(_);
	}

})(function(_) {

	// _socketConnection should be shared between all the models
	// it's a single connection to the server
	var _socketConnection;

	// the socket.io on function isn't avalible until Marilyn gets the socketConnection
	// after it gets this connection all the on events need to get attached to socket.io
	var _eventBuffer = {};

	// the is where all the models will be stored so getters can be used to retrieve them
	var _models = {};

	// get a Model from the global Marilyn object
	var _modelGet = function(modelName) {
		return _models[modelName];
	};

	// create a Model and assign it to the global Marilyn object
	var _modelSet = function(modelName, init) {

		// this is for saving changes to the result generated by read and readOne
		var _resultSave = function(callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			// saveType is used to determine which receiver to fire
			var saveType;

			var runCallback = function(err, result) {

				Model.inform(saveType, result);
				Model.inform('save', result);

				Model._retainContext = callback;
				Model._retainContext(err, result);

			};

			var runSaves = function(err, result) {

				// check if there are any afters assigned to the save
				if (Model._afters.hasOwnProperty('save')) {
					Model._retainContext = Model._afters.save;
					Model._retainContext(result, function() {
						runCallback(err, result);
					});
				} else {
					runCallback(err, result);
				}

			};

			var runUpdateComplete = function(object) {

				Model.updateSilent({
					'__id': object.__id
				}, object, function(err, results) {

					var result = results[0];

					// check if there are any afters assigned to the update
					if (Model._afters.hasOwnProperty('update')) {
						Model._retainContext = Model._afters.update;
						Model._retainContext(result, function() {
							runSaves(err, result);
						});
					} else {
						runSaves(err, result);
					}

				});

			};

			var runCreateComplete = function(object) {

				Model.createSilent(object, function(err, result) {

					// check if there are any afters assigned to the create
					if (Model._afters.hasOwnProperty('create')) {
						Model._retainContext = Model._afters.create;
						Model._retainContext(object, function() {
							runSaves(err, result);
						});
					} else {
						runSaves(err, result);
					}

				});

			};

			// run the correct CRUD method
			var runCRUD = function(object) {

				// CREATE
				// this object is being newly created
				if (!object.hasOwnProperty('__id')) {

					saveType = 'create';

					// check if there are any befores assigned to the create
					if (Model._befores.hasOwnProperty('create')) {
						Model._retainContext = Model._befores.create;
						Model._retainContext(object, function() {
							runCreateComplete(object);
						});
					} else {
						runCreateComplete(object);
					}

				}

				// UPDATE
				// check if the object has come from a read and needs to be updated
				else {

					saveType = 'update';

					// check if there are any befores assigned to the update
					if (Model._befores.hasOwnProperty('update')) {
						Model._retainContext = Model._befores.update;
						Model._retainContext({
							'__id': object.__id
						}, object, function() {
							runUpdateComplete(object);
						});
					} else {
						runUpdateComplete(object);
					}

				}

			};

			// "this" is the result or a new object being created
			var _this = this || {};

			// the save can save a new or existing object using the create or update methods
			// this should trigger the correct befores and afters
			// it should always trigger all the before saves and after saves regardless of it being a create or update

			// check if there are any befores assigned to the save
			if (Model._befores.hasOwnProperty('save')) {
				Model._retainContext = Model._befores.save;
				Model._retainContext(_this, function() {
					runCRUD(_this);
				});
			} else {
				runCRUD(_this);
			}

		};

		// this Model function will be what contains all the CRUD functions
		// it is an function so we can use the 'new' keyword to create one
		var Model = _models[modelName] = function(object) {
			object = object || {};
			object.save = _resultSave;
			return object;
		};

		// PRIVATE PROPERTIES

		// setup the private variables of the Model
		// collection will store all the data in the Model
		Model._collection = [];
		Model._id = 0;

		Model._befores = {};
		Model._afters = {};

		Model._receivers = {};

		// PUBLIC PROPERTIES

		Model._name = modelName;

		// PRIVATE METHODS

		// this is a variable that will be overrided each time context needs to be retained
		Model._retainContext = function() {};

		// private functions
		Model._nextId = function() {
			Model._id++;
			return Model._id;
		};

		// PUBLIC METHODS

		// Socket.IO events

		Model.on = function(eventType, callback) {

			// if the socketConnection is not setup the ons need to get buffered and applied later
			if (!_socketConnection) {

				// set the Model name property if not already set
				if (!_eventBuffer.hasOwnProperty(Model._name)) {
					_eventBuffer[Model._name] = {};
				}

				// set the callback into the onBuffer onject
				_eventBuffer[Model._name][eventType] = callback;

			} else {

				_socketConnection.on(eventType, function(data) {
					Model._retainContext = callback;
					Model._retainContext(data);
				});

			}

		};

		Model.emit = function(eventType, data) {

			if (_socketConnection) {
				_socketConnection.emit(eventType, data);
			}

		};

		// internal events

		Model.before = function(eventType, callback) {
			Model._befores[eventType] = callback;
		};

		Model.beforeRemove = function(eventType) {
			Model._befores[eventType] = function() {};
		};

		Model.after = function(eventType, callback) {
			Model._afters[eventType] = callback;
		};

		Model.afterRemove = function(eventType) {
			Model._afters[eventType] = function() {};
		};

		Model.inform = function(eventType, data) {
			if (Model._receivers[eventType]) {
				Model._retainContext = Model._receivers[eventType];
				Model._retainContext(data);
			}
		};

		Model.receive = function(eventType, callback) {
			Model._receivers[eventType] = callback;
		};

		Model.receiveRemove = function(eventType) {

			if (_.isEmpty(eventType)) {
				Model._receivers = {};
			} else {
				Model._receivers[eventType] = function() {};
			}

		};

		// query methods

		Model.collection = function(collection) {

			// check if the collection is an array
			if (!_.isArray(collection)) {
				// TODO throw error
				return;
			}

			for (var i = 0, j = collection.length; i < j; i++) {
				collection[i].__id = Model._nextId();
			}

			Model._collection = collection;

		};

		Model.create = function(element, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, result) {

				Model.inform('create', result);

				Model._retainContext = callback;
				Model._retainContext(err, result);

			};

			var runComplete = function() {

				Model.createSilent(element, function(err, result) {

					// allow the returned object to be saved in the future
					result.save = _resultSave;

					// check if there are any afters assigned to the create
					if (Model._afters.hasOwnProperty('create')) {
						Model._retainContext = Model._afters.create;
						Model._retainContext(element, function() {
							runCallback(err, result);
						});
					} else {
						runCallback(err, result);
					}

				});

			};

			// check if there are any befores assigned to the create
			if (Model._befores.hasOwnProperty('create')) {
				Model._retainContext = Model._befores.create;
				Model._retainContext(element, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

		};

		Model.createSilent = function(element, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			// set the internal id using the Model's next id
			element.__id = Model._nextId();

			Model._collection.push(element);

			Model._retainContext = callback;
			Model._retainContext(err, element);

		};

		Model.read = function(query, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, results) {

				Model.inform('read', results);

				Model._retainContext = callback;
				Model._retainContext(err, results);

			};

			var runComplete = function() {

				Model.readSilent(query, function(err, results) {

					// check if there are any afters assigned to the read
					if (Model._afters.hasOwnProperty('read')) {
						Model._retainContext = Model._afters.read;
						Model._retainContext(results, function() {
							runCallback(err, results);
						});
					} else {
						runCallback(err, results);
					}

				});

			};

			// check if there are any befores assigned to the read
			if (Model._befores.hasOwnProperty('read')) {
				Model._retainContext = Model._befores.read;
				Model._retainContext(query, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

		};

		Model.readSilent = function(query, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			var readAll = false;

			// if no query was passed
			if (typeof query === 'function') {
				callback = query;
				readAll = true;
			}

			// or if the query object was empty
			else if (_.isEmpty(query)) {
				readAll = true;
			}

			var results = [];

			if (readAll) {
				results = Model._collection;
			} else {
				results = _.where(Model._collection, query);
			}

			// check if results were found
			if (results.length === 0) {
				err = 'item not found';
			}

			// add the save callback to the results
			_.each(results, function(element) {
				element.save = _resultSave;
			});

			Model._retainContext = callback;
			Model._retainContext(err, results);

		};

		Model.readOne = function(query, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, result) {

				Model.inform('readOne', result);

				Model._retainContext = callback;
				Model._retainContext(err, result);

			};

			var runComplete = function() {

				Model.readOneSilent(query, function(err, result) {

					// check if there are any afters assigned to the readOne
					if (Model._afters.hasOwnProperty('readOne')) {
						Model._retainContext = Model._afters.readOne;
						Model._retainContext(result, function() {
							runCallback(err, result);
						});
					} else {
						runCallback(err, result);
					}

				});

			};

			// check if there are any befores assigned to the readOne
			if (Model._befores.hasOwnProperty('readOne')) {
				Model._retainContext = Model._befores.readOne;
				Model._retainContext(query, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

		};

		Model.readOneSilent = function(query, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			var results = _.where(Model._collection, query);

			var result = null;

			if (results[0]) {
				result = results[0];
				result.save = _resultSave;
			} else {
				err = 'item not found';
			}

			Model._retainContext = callback;
			Model._retainContext(err, result);

		};

		Model.update = function(query, changes, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, results) {

				Model.inform('update', results);

				Model._retainContext = callback;
				Model._retainContext(err, results);

			};

			var runComplete = function() {

				Model.updateSilent(query, changes, function(err, results) {

					// check if there are any afters assigned to the update
					if (Model._afters.hasOwnProperty('update')) {
						Model._retainContext = Model._afters.update;
						Model._retainContext(results, function() {
							runCallback(err, results);
						});
					} else {
						runCallback(err, results);
					}

				});

			};

			// check if there are any befores assigned to the update
			if (Model._befores.hasOwnProperty('update')) {
				Model._retainContext = Model._befores.update;
				Model._retainContext(query, changes, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

		};

		Model.updateSilent = function(query, changes, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			var results = _.where(Model._collection, query);

			if (results.length > 0) {

				_.each(results, function(element) {

					_.each(changes, function(value, key) {
						element[key] = value;
					});

				});

			} else {
				err = 'item not found';
			}

			Model._retainContext = callback;
			Model._retainContext(err, results);

		};

		Model.del = function(query, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, results) {

				Model.inform('delete', results);

				// callback if from the parent function
				Model._retainContext = callback;
				Model._retainContext(err, results);

			};

			var runComplete = function() {

				Model.deleteSilent(query, function(err, results) {

					// check if there are any afters assigned to the delete
					if (Model._afters.hasOwnProperty('delete')) {
						Model._retainContext = Model._afters['delete'];
						Model._retainContext(results, function() {
							runCallback(err, results);
						});
					} else {
						runCallback(err, results);
					}

				});

			};

			// check if there are any befores assigned to the delete
			if (Model._befores.hasOwnProperty('delete')) {
				Model._retainContext = Model._befores['delete'];
				Model._retainContext(query, function() {
					runComplete();
				});
			} else {
				runComplete();
			}

		};

		Model.delSilent = function(query, callback) {

			// check if the callback if a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			var results = _.where(Model._collection, query);

			if (results.length > 0) {

				_.each(results, function(element) {

					var index = _.indexOf(Model._collection, element);
					Model._collection.splice(index, 1);

				});

			} else {
				err = 'item not found';
			}

			Model._retainContext = callback;
			Model._retainContext(err, results);

		};

		// aliases
		Model.find = Model.read;
		Model.findSilent = Model.readSilent;
		Model.findOne = Model.readOne;
		Model.findOneSilent = Model.readOneSilent;

		Model['delete'] = Model.del;
		Model.deleteSilent = Model.delSilent;

		// run the callback init function if it was passed
		if (init) {

			// make "this" work inside of the callback
			Model.init = init;
			Model.init();

			// delete the init function as it should only run once
			delete Model.init;

		}

		return Model;

	};

	// create the marilyn object
	var marilyn = {};

	marilyn.VERSION = '0.12.0';

	marilyn.config = function(socketConnection) {

		_socketConnection = socketConnection;

		// setup the ons
		for (var model in _eventBuffer) {

			for (var eventType in _eventBuffer[model]) {

				// this has to be a self executing function to retain scope through dependency injection
				(function(model, eventType, callback) {

					_socketConnection.on(eventType, function(data) {
						model._retainContext = callback;
						model._retainContext(data);
					});

				})(_models[model], eventType, _eventBuffer[model][eventType]);

			}

		}

		_eventBuffer = {};

	};

	marilyn.model = function(modelName, init) {
		if (_models[modelName]) {
			return _modelGet(modelName);
		} else {
			return _modelSet(modelName, init);
		}
	};

	marilyn.modelRemove = function(modelName) {
		_models[modelName] = null;
	};

	marilyn.receiveRemove = function(modelName) {
		for (var model in _models) {
			_models[model].receiveRemove();
		}
	};

	return marilyn;

});