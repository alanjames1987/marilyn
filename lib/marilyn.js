(function(factory) {

	// define marilyn using AMD
	if (typeof define === 'function' && define.amd) {
		define(['underscore'], factory);
	}

	// define marilyn by adding it to the window object
	else {
		window.Marilyn = window.marilyn = factory(_);
	}

})(function(_) {

	// _socketConnection should be shared between all the models
	// it's a single connection to the server
	var _socketConnection;

	// the socket.io on function isn't avalible until Marilyn gets the socketConnection
	// after it gets this connection all the on events need to get attached to socket.io
	var _onEventBuffer = {};

	// the socket.io emit function isn't avalible until Marilyn gets the socketConnection
	// after it gets this connection all the emit events need to get sent to socket.io
	var _emitEventBuffer = [];

	// the is where all the models will be stored so getters can be used to retrieve them
	var _models = {};

	// get a Model from the global Marilyn object
	var _modelGet = function(modelName) {
		return _models[modelName];
	};

	// create a Model and assign it to the global Marilyn object
	var _modelSet = function(modelName, options, init) {

		// if the model already exists
		// return the model
		if (_modelGet(modelName)) {
			return _modelGet(modelName);
		}

		// if the options parameter is the initalization function set it
		if (typeof options === 'function') {
			init = options;
		}

		// this is for saving changes to the result generated by read and readOne
		var _resultSave = function(callback) {

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			// saveType is used to determine which receiver to fire
			var saveType;

			var runCallback = function(err, result) {

				// this is needed to send an object
				if (saveType === 'createOne') {
					Model.$inform('createOne', result);
				}

				// this is needed to send an array
				else if (saveType === 'updateOne') {
					Model.$inform('updateOne', [result]);
				}

				Model.$inform('save', result);

				// call the callback that was passed into the save
				callback.call(Model, err, result);

			};

			var runSaves = function(err, result) {

				// check if there are any afters assigned to the save
				if (Model._afters.hasOwnProperty('save')) {

					// call the after save callback
					Model._afters.save.call(Model, result, function() {
						runCallback(err, result);
					});

				} else {
					runCallback(err, result);
				}

			};

			var runUpdateComplete = function(object) {

				Model.$updateManySilent({
					'$id': object.$id
				}, object, function(err, results) {

					var result = results[0];

					// check if there are any afters assigned to the updateOne
					if (Model._afters.hasOwnProperty('updateOne')) {

						// call the adfter updateOne callback
						Model._afters.updateOne.call(Model, results, function() {
							runSaves(err, result);
						});

					} else {
						runSaves(err, result);
					}

				});

			};

			var runCreateComplete = function(object) {

				Model.$createOneSilent(object, function(err, result) {

					// check if there are any afters assigned to the createOne
					if (Model._afters.hasOwnProperty('createOne')) {

						// call the after createOne callback
						Model._afters.createOne.call(Model, object, function() {
							runSaves(err, result);
						});

					} else {
						runSaves(err, result);
					}

				});

			};

			// run the correct CRUD method
			var runCRUD = function(object) {

				// CREATE
				// this object is being newly created
				if (!object.hasOwnProperty('$id')) {

					saveType = 'createOne';

					// check if there are any befores assigned to the createOne
					if (Model._befores.hasOwnProperty('createOne')) {

						// call the before createOne callback
						Model._befores.createOne.call(Model, object, function() {
							runCreateComplete(object);
						});

					} else {
						runCreateComplete(object);
					}

				}

				// UPDATE
				// check if the object has come from a read and needs to be updated
				else {

					saveType = 'updateOne';

					// check if there are any befores assigned to the updateOne
					if (Model._befores.hasOwnProperty('updateOne')) {

						// call the before updateOne callback
						Model._befores.updateOne.call(Model, {
							'$id': object.$id
						}, object, function() {
							runUpdateComplete(object);
						});

					} else {
						runUpdateComplete(object);
					}

				}

			};

			// "this" is the result or a new object being created
			var _this = this || {};

			// the save can save a new or existing object using the createOne or updateOne methods
			// this should trigger the correct befores and afters
			// it should always trigger all the before saves and after saves regardless of it being a createOne or updateOne

			// check if there are any befores assigned to the save
			if (Model._befores.hasOwnProperty('save')) {

				// call the before save callback
				Model._befores.save.call(Model, _this, function() {
					runCRUD(_this);
				});

			} else {
				runCRUD(_this);
			}

		};

		var _resultDelete = function(callback) {

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			// "this" will always reference the item being deleted
			Model.$deleteMany(this, callback);

		};

		var _resultDeleteSilent = function(callback) {

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			// "this" will always reference the item
			Model.$deleteManySilent(this, callback);

		};

		// this Model function will be what contains all the CRUD functions
		// it is an function so we can use the "new" keyword to create
		var Model = _models[modelName] = function(object) {

			object = object || {};

			// add additional methods to the object
			object.$save = _resultSave;

			// we don't need to add the delete methods
			// they get added when the save method is called

			return object;

		};

		// PRIVATE PROPERTIES

		// setup the private variables of the Model
		// collection will store all the data in the Model
		Model._collection = [];
		Model._id = 0;

		Model._befores = {};
		Model._afters = {};

		Model._receivers = {};

		Model._name = modelName;

		// PRIVATE METHODS

		Model._nextId = function() {
			Model._id++;
			return Model._id;
		};

		// PUBLIC METHODS

		// Socket.IO events

		Model.$on = function(eventType, callback) {

			// if the socketConnection is not setup the ons need to get buffered and applied later
			if (!_socketConnection) {

				// set the Model name property if not already set
				if (!_onEventBuffer.hasOwnProperty(Model._name)) {
					_onEventBuffer[Model._name] = {};
				}

				// set the callback into the onBuffer object
				_onEventBuffer[Model._name][eventType] = callback;

			} else {

				_socketConnection.on(eventType, function(data) {
					callback.call(Model, data);
				});

			}

		};

		Model.$emit = function(eventType, data, data2) {

			// if the socketConnection is not setup the emits need to get buffered and sent later
			if (!_socketConnection) {

				// push the event and data into the emitBuffer object
				_emitEventBuffer.push([eventType, data, data2]);

			} else {

				_socketConnection.emit(eventType, data, data2);

			}

		};

		// internal events

		Model.$use = function(pluginCallback) {
			// call the plugin callback
			pluginCallback.call(Model);
		};

		// listen for a before event
		Model.$before = function(eventType, callback) {

			// the event was a single event
			// no need to setup multiple
			if (_.isString(eventType)) {

				// if the event starts with a $ remove it
				if (eventType[0] === '$') {
					eventType = eventType.substring(1);
				}

				Model._befores[eventType] = callback;

			}

			// multiple events were passed in
			else if (_.isArray(eventType)) {

				_.each(eventType, function(key) {

					// if the event starts with a $ remove it
					if (key[0] === '$') {
						key = key.substring(1);
					}

					Model._befores[key] = callback;

				});

			}

		};

		// remove a before event listener
		Model.$beforeRemove = function(eventType) {

			// the event was a single event
			// no need to remove multiple
			if (_.isString(eventType)) {

				// if the event starts with a $ remove it
				if (eventType[0] === '$') {
					eventType = eventType.substring(1);
				}

				Model._befores[eventType] = function() {};

			}

			// multiple events were passed in
			else if (_.isArray(eventType)) {

				_.each(eventType, function(key) {

					// if the event starts with a $ remove it
					if (key[0] === '$') {
						key = key.substring(1);
					}

					Model._befores[key] = function() {};

				});

			}

		};

		// listen for an after event
		Model.$after = function(eventType, callback) {

			// the event was a single event
			// no need to setup multiple
			if (_.isString(eventType)) {

				// if the event starts with a $ remove it
				if (eventType[0] === '$') {
					eventType = eventType.substring(1);
				}

				Model._afters[eventType] = callback;

			}

			// multiple events were passed in
			else if (_.isArray(eventType)) {

				_.each(eventType, function(key) {

					// if the event starts with a $ remove it
					if (key[0] === '$') {
						key = key.substring(1);
					}

					Model._afters[key] = callback;

				});

			}

		};

		// remove an after event listener
		Model.$afterRemove = function(eventType) {

			// the event was a single event
			// no need to remove multiple
			if (_.isString(eventType)) {

				// if the event starts with a $ remove it
				if (eventType[0] === '$') {
					eventType = eventType.substring(1);
				}

				Model._afters[eventType] = function() {};

			}

			// multiple events were passed in
			else if (_.isArray(eventType)) {

				_.each(eventType, function(key) {

					// if the event starts with a $ remove it
					if (key[0] === '$') {
						key = key.substring(1);
					}

					Model._afters[key] = function() {};

				});

			}

		};

		// trigger a receive
		Model.$inform = function(eventType, data) {

			// if the event starts with a $ remove it
			if (eventType[0] === '$') {
				eventType = eventType.substring(1);
			}

			if (Model._receivers[eventType]) {
				// call the receiver callback
				Model._receivers[eventType].call(Model, data);
			}

		};

		// listen for an inform
		Model.$receive = function(eventType, callback) {

			// the event was a single event
			// no need to setup multiple
			if (_.isString(eventType)) {

				// if the event starts with a $ remove it
				if (eventType[0] === '$') {
					eventType = eventType.substring(1);
				}

				Model._receivers[eventType] = callback;

			}

			// multiple events were passed in
			else if (_.isArray(eventType)) {

				_.each(eventType, function(key) {

					// if the event starts with a $ remove it
					if (key[0] === '$') {
						key = key.substring(1);
					}

					Model._receivers[key] = callback;

				});

			}

		};

		// remove a receive event listener
		Model.$receiveRemove = function(eventType) {

			// remove all receivers if the event type is not specified
			if (_.isEmpty(eventType)) {
				Model._receivers = {};
			}

			// remove specific receivers
			else {

				// the event was a single event
				// no need to remove multiple
				if (_.isString(eventType)) {

					// if the event starts with a $ remove it
					if (eventType[0] === '$') {
						eventType = eventType.substring(1);
					}

					Model._receivers[eventType] = function() {};

				}

				// multiple events were passed in
				else if (_.isArray(eventType)) {

					_.each(eventType, function(key) {

						// if the event starts with a $ remove it
						if (key[0] === '$') {
							key = key.substring(1);
						}

						Model._receivers[key] = function() {};
					});

				}

			}

		};

		// query methods

		// replaces the internal collection with a new array of objects
		// this will add an $id property
		// it will also change the collection in a data binding friendly way
		Model.$collection = function(collection) {

			// check if the collection is an array
			if (!_.isArray(collection)) {
				// TODO throw error
				return;
			}

			// replace the collection like this for data binding
			while (Model._collection.length > 0) {
				Model._collection.pop();
			}

			for (var i = 0, j = collection.length; i < j; i++) {
				collection[i].$id = Model._nextId();
				Model._collection.push(collection[i]);
			}

		};

		// CREATE

		Model.$createOne = function(object, callback) {

			// store a clone of the query for later reference
			var originalQuery = _.clone(object);

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, result) {

				Model.$inform('createOne', result);

				// call the callback that was passed into the createOne
				callback.call(Model, err, result);

			};

			var runComplete = function() {

				Model.$createOneSilent(object, function(err, result) {

					// check if there are any afters assigned to the createOne
					if (!Model._afters.hasOwnProperty('createOne')) {
						runCallback(err, result);
						return;
					}

					// if the function is expecting 3 arguments pass the query, result, and callback
					if (Model._afters.createOne.length == 3) {
						Model._afters.createOne.call(Model, originalQuery, result, function() {
							runCallback(err, result);
						});
						return;
					}

					// if the function is expecting 2 arguments only pass the result and callback
					Model._afters.createOne.call(Model, result, function() {
						runCallback(err, result);
					});

				});

			};

			// check if there are any befores assigned to the create
			if (!Model._befores.hasOwnProperty('createOne')) {
				runComplete();
				return;
			}

			// call the before createOne callback
			Model._befores.createOne.call(Model, object, function() {
				runComplete();
			});

		};

		Model.$createOneSilent = function(object, callback) {

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			// set the internal id using the Model's next id
			object.$id = Model._nextId();

			// allow the returned object to be saved in the future
			object.$save = _resultSave;

			object.$deleteOne = function(callback) {
				_resultDelete.call(object, callback);
			};

			object.$deleteOneSilent = function(callback) {
				_resultDeleteSilent.call(object, callback);
			};

			Model._collection.push(object);

			// call the callback that was passed into the createOneSilent
			callback.call(Model, err, object);

		};

		// READ

		Model.$readMany = function(query, callback) {

			// store a clone of the query for later reference
			var originalQuery = _.clone(query);

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, results) {

				Model.$inform('readMany', results);

				// call the callback that was passed into the read
				callback.call(Model, err, results);

			};

			var runComplete = function() {

				Model.$readManySilent(query, function(err, results) {

					// check if there are any afters assigned to the read
					if (!Model._afters.hasOwnProperty('readMany')) {
						runCallback(err, results);
						return;
					}

					// if the function is expecting 3 arguments pass the query, results, and callback
					if (Model._afters.readMany.length == 3) {
						Model._afters.readMany.call(Model, originalQuery, results, function() {
							runCallback(err, results);
						});
						return;
					}

					// if the after function is expecting anything else send back the expected result and a callback
					Model._afters.readMany.call(Model, results, function() {
						runCallback(err, results);
					});

				});

			};

			// check if there are any befores assigned to the readMany
			if (!Model._befores.hasOwnProperty('readMany')) {
				runComplete();
				return;
			}

			// call the before readMany callback
			Model._befores.readMany.call(Model, query, function() {
				runComplete();
			});

		};

		Model.$readManySilent = function(query, callback) {

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			var readAll = false;

			// if no query was passed
			if (typeof query === 'function') {
				callback = query;
				readAll = true;
			}

			// or if the query object was empty
			else if (_.isEmpty(query)) {
				readAll = true;
			}

			var results = [];

			if (readAll) {
				results = Model._collection;
			} else {
				results = _.where(Model._collection, query);
			}

			// add additional methods to the results
			_.each(results, function(result) {

				result.$save = _resultSave;

				result.$deleteOne = function(callback) {
					_resultDelete.call(result, callback);
				};

				result.$deleteOneSilent = function(callback) {
					_resultDeleteSilent.call(result, callback);
				};

			});

			// call the callback that was passed into the readManySilent
			callback.call(Model, err, results);

		};

		Model.$readOne = function(query, callback) {

			// store a clone of the query for later reference
			var originalQuery = _.clone(query);

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, result) {

				Model.$inform('readOne', result);

				// call the callback that was passed into the readOne
				callback.call(Model, err, result);

			};

			var runComplete = function() {

				Model.$readOneSilent(query, function(err, result) {

					// check if there are any afters assigned to the readOne
					if (!Model._afters.hasOwnProperty('readOne')) {
						runCallback(err, result);
						return;
					}

					// if the function is expecting 3 arguments pass the query, result, and callback
					if (Model._afters.readOne.length == 3) {
						Model._afters.readOne.call(Model, originalQuery, result, function() {
							runCallback(err, result);
						});
						return;
					}

					Model._afters.readOne.call(Model, result, function() {
						runCallback(err, result);
					});

				});

			};

			// check if there are any befores assigned to the readOne
			if (Model._befores.hasOwnProperty('readOne')) {

				// call the before readOne callback
				Model._befores.readOne.call(Model, query, function() {
					runComplete();
				});

			} else {
				runComplete();
			}

		};

		Model.$readOneSilent = function(query, callback) {

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			var results = _.where(Model._collection, query);

			var result = null;

			if (results[0]) {

				result = results[0];

				// add additonal methods to the result
				result.$save = _resultSave;

				result.$deleteOne = function(callback) {
					_resultDelete.call(result, callback);
				};

				result.$deleteOneSilent = function(callback) {
					_resultDeleteSilent.call(result, callback);
				};

			}

			// call the callback that was passed into the readOneSilent
			callback.call(Model, err, result);

		};

		// UPDATE

		Model.$updateMany = function(query, changes, callback) {

			// store a clone of the query for later reference
			var originalQuery = _.clone(query);
			var originalChanges = _.clone(changes);

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, results) {

				Model.$inform('updateMany', results);

				// call the callback that was passed into the updateMany
				callback.call(Model, err, results);

			};

			var runComplete = function() {

				Model.$updateManySilent(query, changes, function(err, results) {

					// check if there are any afters assigned to the update
					if (!Model._afters.hasOwnProperty('updateMany')) {
						runCallback(err, results);
						return;
					}

					// if the function is expecting 4 arguments pass the err, query, results, and callback
					if (Model._afters.updateMany.length == 4) {
						Model._afters.updateMany.call(Model, originalQuery, originalChanges, results, function() {
							runCallback(err, results);
						});
						return;
					}

					// if the after function is expecting anything else send back the expected result and a callback
					Model._afters.updateMany.call(Model, results, function() {
						runCallback(err, results);
					});

				});

			};

			// check if there are any befores assigned to the updateMany
			if (!Model._befores.hasOwnProperty('updateMany')) {
				runComplete();
				return;
			}

			// call the before update callback
			Model._befores.updateMany.call(Model, query, changes, function() {
				runComplete();
			});

		};

		Model.$updateManySilent = function(query, changes, callback) {

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			var results = _.where(Model._collection, query);

			if (results.length > 0) {

				_.each(results, function(object) {

					_.each(changes, function(value, key) {
						object[key] = value;
					});

				});

			}

			// call the callback that was passed into the updateManySilent
			callback.call(Model, err, results);

		};

		// DELETE

		Model.$deleteMany = function(query, callback) {

			// store a clone of the query for later reference
			var originalQuery = _.clone(query);

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var runCallback = function(err, results) {

				Model.$inform('deleteMany', results);

				// call the callback that was passed into the del
				callback.call(Model, err, results);

			};

			var runComplete = function() {

				Model.$deleteManySilent(query, function(err, results) {

					// check if there are any afters assigned to the delete
					if (!Model._afters.hasOwnProperty('deleteMany')) {
						runCallback(err, results);
						return;
					}

					// if the function is expecting 3 arguments pass the query, results, and callback
					if (Model._afters.deleteMany.length == 3) {
						Model._afters.deleteMany.call(Model, originalQuery, results, function() {
							runCallback(err, results);
						});
						return;
					}

					Model._afters.deleteMany.call(Model, results, function() {
						runCallback(err, results);
					});


				});

			};

			// check if there are any befores assigned to the delete
			if (!Model._befores.hasOwnProperty('deleteMany')) {
				runComplete();
				return;
			}

			// call the before delete callback
			Model._befores.deleteMany.call(Model, query, function() {
				runComplete();
			});

		};

		Model.$deleteManySilent = function(query, callback) {

			// check if the callback is a valid function
			callback = (callback && _.isFunction(callback)) ? callback : function() {};

			var err = null;

			var results = _.where(Model._collection, query);

			if (results.length > 0) {

				_.each(results, function(object) {

					var index = _.indexOf(Model._collection, object);
					Model._collection.splice(index, 1);

				});

			}

			// call the callback that was passed into the delSilent
			callback.call(Model, err, results);

		};

		// aliases

		Model.$find = Model.$read;
		Model.$findSilent = Model.$readManySilent;
		Model.$findOne = Model.$readOne;
		Model.$findOneSilent = Model.$readOneSilent;

		Model.$get = Model.$read;
		Model.$getSilent = Model.$read;
		Model.$get = Model.$read;
		Model.$getSilent = Model.$read;

		// run the callback init function if it was passed passing the Model as the "this"
		init = (init && _.isFunction(init)) ? init : function() {};
		init.call(Model);

		return Model;

	};

	// create the marilyn object
	var marilyn = {};

	marilyn.VERSION = '1.0.0';

	marilyn.config = function(socketConnection) {

		_socketConnection = socketConnection;

		// setup the ons
		for (var model in _onEventBuffer) {

			for (var eventType in _onEventBuffer[model]) {

				// this has to be a self executing function to retain scope through dependency injection
				(function(model, eventType, callback) {

					_socketConnection.on(eventType, function(data) {
						callback.call(model, data);
					});

				})(_models[model], eventType, _onEventBuffer[model][eventType]);

			}

		}

		// send the emits
		for (var i = 0, j = _emitEventBuffer.length; i < j; i++) {
			_socketConnection.emit(_emitEventBuffer[i][0], _emitEventBuffer[i][1], _emitEventBuffer[i][2]);
		}

		_onEventBuffer = {};

	};

	marilyn.model = function(modelName, init) {

		if (_models[modelName] && !init) {
			return _modelGet(modelName);
		}

		return _modelSet(modelName, init);

	};

	marilyn.modelRemove = function(modelName) {
		_models[modelName] = null;
	};

	marilyn.receiveRemove = function(modelName) {
		for (var model in _models) {
			_models[model].receiveRemove();
		}
	};

	return marilyn;

});